---
layout: post
title: "Edge-distance anti-aliasing"
date: 2012-08-14
comments: false
---

<div class='post'>
<br /><div style="text-align: center;">(<a href="http://abandonedwig.info/edge-distance-anti-aliasing/demo.html">straight to the demo, you fool</a>)</div><div style="text-align: center;"><br /></div>Some months ago, I noticed that the <a href="http://trac.webkit.org/browser/trunk/Source/WebCore/platform/graphics/chromium/cc">Chromium compositor</a>, the code which powers&nbsp;Chromium's accelerated compositing implementation (and also <a href="https://sites.google.com/a/chromium.org/dev/developers/design-documents/aura-desktop-window-manager">Aura</a>!), was&nbsp;anti-aliasing layer edges. This was especially surprising to me since I knew&nbsp;for a fact that my hardware didn't support <a href="http://en.wikipedia.org/wiki/Multisample_anti-aliasing">multisample anti-aliasing</a> yet.<br /><br />I puzzled over this for a bit before finally asking around. The Chromium&nbsp;graphics team, who are incredibly friendly and helpful, pointed me to a very&nbsp;clever bit of code they were using to do edge-distance anti-aliasing for&nbsp;composited layers.<br /><br /><a href="http://aliasing/">Aliasing</a> can happen when you sample a signal that has smaller details&nbsp;than your sample size In the case of graphics, it's&nbsp;what happens when features of the image exist in an area smaller than a pixel.&nbsp;One important feature is the edge of a piece of geometry, such as the edge of a<br />shape drawn onto the page. &nbsp;When you start rotating shapes and projecting with 3D&nbsp;CSS transforms, geometry that before aligned to pixel boundaries can move to a&nbsp;space between pixel boundaries.<br /><br />For instance, let's zoom into the edge of triangle that we are rendering. Maybe&nbsp;in this case it's half of a rotated div.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-HdAHWjw-vWA/UCqAttTRzLI/AAAAAAAAAWI/PPwy4VIauG0/s1600/no-antialiasing-final.png" imageanchor="1"><img border="0" src="http://3.bp.blogspot.com/-HdAHWjw-vWA/UCqAttTRzLI/AAAAAAAAAWI/PPwy4VIauG0/s1600/no-antialiasing-final.png" /></a></div><br /><br />If we naively decided the color of every pixel based on whether any of the&nbsp;triangle covered it at all, we'd end up with a jagged edge.<br /><br />One thing we could do to make the edge smooth is to determine how much area of&nbsp;the pixel is covered by the triangle. We could adjust the transparency of the&nbsp;shape color (the alpha value) by that percentage when painting the pixel. This&nbsp;process is called <i>anti-aliasing</i> and the percentage that the triangle<br />covers the pixel is called <i>coverage</i>.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/--qRmraD88vE/UCqA8OlRJpI/AAAAAAAAAWQ/DTUGQkjvqVA/s1600/antialiasing-final.png" imageanchor="1"><img border="0" src="http://1.bp.blogspot.com/--qRmraD88vE/UCqA8OlRJpI/AAAAAAAAAWQ/DTUGQkjvqVA/s1600/antialiasing-final.png" /></a></div><br /><br />Think of all the complicated geometric calculations we'd have to do to figure&nbsp;out the ratio exactly. Since we have to make these calculations for every pixel&nbsp;up to 60 times per second (for smooth animations), our rendering would be&nbsp;pretty slow if we actually did them! Instead, it'd be nice if we could somehow<br />estimate how much of the pixel is covered and do less work. One approach is to&nbsp;calculate the distance from the pixel to the edge of the shape. If the pixel is&nbsp;more than one pixel's distance away from the edge, we know that we should not&nbsp;paint the triangle color at all. If the pixel is closer than one one pixel's&nbsp;distance from the edge, we should paint the triangle color, but reduced by some&nbsp;transparency factor.<br /><br />Luckily, OpenGL can run a little program for every pixel <sup>[1]</sup> it paints. This&nbsp;program is called a fragment shader. We can write up this logic in the fragment&nbsp;shader and change the triangle color for every pixel.<br /><br />Perhaps some of those reading who have had experience with OpenGL may notice&nbsp;here that this isn't going to work as I've described it. OpenGL already does&nbsp;something like the naive approach I talked about first. Some pixels (the ones&nbsp;OpenGL decided should be painted with the triangle color), will be properly&nbsp;anti-aliased, but many pixels will not be painted at all. &nbsp;For instance, if&nbsp;the coverage of the pixel is only 20% and OpenGL decided not to paint it, we&nbsp;wouldn't even have a chance to determine how far it was from the triangle edge,&nbsp;because the fragment shader wouldn't run for those missing pixels.<br /><br />Let's "trick" OpenGL into painting more pixels than it would otherwise. A&nbsp;simple way to do this is to just make the triangle a little bit bigger. In&nbsp;fact, we can expand all the edges by less than pixel's distance and OpenGL will&nbsp;paint all those missing pixels. Now we have smooth edges!<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-XHL3ZHXhfls/UCqBReX44UI/AAAAAAAAAWY/cGZBQ1exRJ0/s1600/antialiasing-final-expanded.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-XHL3ZHXhfls/UCqBReX44UI/AAAAAAAAAWY/cGZBQ1exRJ0/s1600/antialiasing-final-expanded.png" /></a></div><br /><br />I spent some time implementing this for the TextureMapper accelerated&nbsp;compositor (and thus WebKitGTK+), so it's not just the Chromium compositor that&nbsp;has this feature any longer. For me it makes a huge difference in the quality&nbsp;of 3D CSS content.&nbsp;For the purposes of demonstration, I've also reimplemented this <a href="http://abandonedwig.info/edge-distance-anti-aliasing/demo.html">anti-aliasing&nbsp;in WebGL</a>, so if you have a modern browser you can see it in action by now by&nbsp;clicking the image below.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://abandonedwig.info/edge-distance-anti-aliasing/demo.html"><img alt="" border="0" src="http://3.bp.blogspot.com/-SA51Ng3N9Bo/UCqCtSc90vI/AAAAAAAAAWg/Pw4pyE49tsU/s1600/demo.png" title="" /></a></div><br /><br />There are a lot of interesting details about this process, so I hope to write&nbsp;more about them in the near future.<br /><br />1. Fragments and pixels are actually different things, but I'm glossing over this&nbsp;difference for the sake of simplicity.<br /><div><br /></div></div>
