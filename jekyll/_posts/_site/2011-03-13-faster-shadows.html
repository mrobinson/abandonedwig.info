<div class='post'>
One area we paid particular attention last year at <a href="http://igalia.com/">Igalia</a> was the performance of shadow rendering in web content. While web shadows are not yet ubiquitous, a slow shadow implementation can cause poor scrolling and redraw performance, ruining your day like an afternoon full of stepping in wet cement. Until recently, the GTK+ (and all Cairo) ports had one of these slow shadow implementations. Scrolling through identi.ca posts could lock Epiphany's user interface for several painful seconds. Alex and I set out to improve this situation.<br /><br />I separate shadowed web content into three categories: CSS <a href="http://www.w3.org/TR/css3-background/#the-box-shadow">box</a> and <a href="http://www.w3.org/TR/2011/WD-css3-text-20110215/#text-shadow">text shadows</a>, <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#shadows">canvas shadows</a> and SVG shadows. Even though a different standard addresses each of these categories of shadows, the process of drawing the shadow remains very similar. The web rendering engine simply draws a copy of the shadowed object underneath itself with a solid fill (the shadow fill). This "shadow image" may also be blurred with a certain radius. For each of the standards that I mentioned, it is sufficient to blur the shadow image by estimating a <a href="http://en.wikipedia.org/wiki/Gaussian_blur">Gaussian blur</a> on its pixels.<br /><br />A Gaussian blur is just the application of the <a href="http://en.wikipedia.org/wiki/Normal_distribution">normal distribution</a> to the pixel values of an image. The value of a pixel in the blurred image is calculated by combining the values of the pixels around it in the original image. The contribution of a particular surrounding pixel decreases with the distance from the target pixel. Until recently the Cairo port performed an <em>actual</em> Gaussian blur with an expensive two-dimensional kernel. The&nbsp;first speed improvement involved making <a href="http://ariya.blogspot.com/">Ariya Hidayat's</a> <a href="http://trac.webkit.org/changeset/67559">fast blurring algorithm</a> (for the Qt port) cross-platform and using it for our own shadows. This algorithm estimates a Gaussian blur by performing multiple one-dimension motion blurs. This decreases the number of pixels that need to be read to calculate a target pixel and also increases the number of cache hits during the blurring calculation.<br /><br />In the course of our work we realized that we were not clipping the shadowed area when blurring. For instance, <a href="http://identi.ca/">identi.ca</a> has one long column of content that extends down the page with a box blur. Instead of blurring just the part of the column visible in the viewport, we were blurring the entire box. This simple fix alone was enough to make most sites usable.<br /><br />Alex performed the <a href="http://trac.webkit.org/changeset/69092">final and most novel optimization</a> for box shadows. Here's an image extremely typical web content with a shadowed div.<br /><br /><div class="separator" style="clear: both; text-align: center;"><img border="0" height="281" src="http://1.bp.blogspot.com/-gOVZs7QvkKE/TX1JPbbEBfI/AAAAAAAAAOs/u2USjvvJbB4/s400/one.png" width="283" /></div>If we remove everything but the shadow we are left with what you see below. A lot of this information is repeated. In fact, we can divide the image into nine regions of unique information. Obviously we are calculating the same few values over and over again. Keep in mind that the slowest part of creating a blurry shadow is estimating the Gaussian.<br /><br /><div class="separator" style="clear: both; text-align: center;"><img border="0" height="273" src="http://3.bp.blogspot.com/-RA4OeJrGq2M/TX1JkqtBD5I/AAAAAAAAAO0/9yzV_PIEAIY/s400/two.png" width="270" /><br /><img border="0" height="273" src="http://2.bp.blogspot.com/-z9fSUszyz-w/TX1Jtxe3GII/AAAAAAAAAO8/rTENqnWATZ0/s400/three.png" width="270" /><br /></div>Each of non-corner regions of the box are made up of the same row of pixels repeated down their length.  In fact, if we had only one a single row of those blurred pixels we could just copy it into the region where the shadow belongs. This is precisely what Alex's implementation does. Instead of rendering the large shadowed area above, we can simply calculate a smaller box and copy the data into the target image.  <br /><br /><div class="separator" style="clear: both; text-align: center;"><img border="0" height="110" src="http://3.bp.blogspot.com/-np4whfyd0XE/TX1J4dbGXHI/AAAAAAAAAPE/ftm-67jio1w/s400/four.png" width="120" /></div>I'm quite pleased with the performance of shadows now. There are a few more optimizations we could do, such as extending the tiling optimization to inset shadows. In fact, the Mac port has made our implementation cross-platform and has already added support for inset shadows. Hopefully more WebKit ports will soon be able to benefit from these optimizations.</div>
