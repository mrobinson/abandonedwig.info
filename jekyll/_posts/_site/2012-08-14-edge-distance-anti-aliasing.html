<p>(You might want to go <a href='/edge-distance-anti-aliasing/demo.html'>straight to the demo</a>)</p>

<p>Some months ago, I noticed that the <a href='http://src.chromium.org/viewvc/chrome/trunk/src/cc/'>Chromium compositor</a>, the code which powers Chromium&#8217;s accelerated compositing implementation (and also <a href='http://code.google.com/p/chromium/wiki/Aura'>Aura!</a>) was anti-aliasing layer edges. This was especially surprising to me since I knew for a fact that my hardware didn&#8217;t support <a href='http://en.wikipedia.org/wiki/Multisample_anti-aliasing'>multisample anti-aliasing</a> yet. Some people from the Chromium graphics team, who are incredibly friendly and helpful, pointed me to a very clever bit of code they were using to do edge-distance anti-aliasing for composited layers.</p>

<p><a href='http://en.wikipedia.org/wiki/Aliasing'>Aliasing</a> can happen when you sample a signal that has smaller details than your sample size In the case of graphics, it&#8217;s what happens when features of the image exist in an area smaller than a pixel. One important feature is the edge of a piece of geometry, such as the edge of a<br />shape drawn onto the page. When you start rotating shapes and projecting with 3D CSS transforms, geometry that before aligned to pixel boundaries can move to a space between pixel boundaries.</p>

<p>For instance, let&#8217;s zoom into the edge of triangle that we are rendering. Maybe in this case it&#8217;s half of a rotated div.</p>

<p><img alt='A polygon without anti-aliasing' src='/edge-distance-anti-aliasing/no-antialiasing-final.png' /></p>

<p>If we naively decided the color of every pixel based on whether any of the triangle covered it at all, we&#8217;d end up with a jagged edge.</p>

<p>One thing we could do to make the edge smooth is to determine how much area of the pixel is covered by the triangle. We could adjust the transparency of the shape color (the alpha value) by that percentage when painting the pixel. This process is called <i>anti-aliasing</i> and the percentage that the triangle covers the pixel is called <i>coverage</i>.</p>

<p><img alt='A polygon with anti-aliasing' src='/edge-distance-anti-aliasing/antialiasing-final.png' /></p>

<p>Think of all the complicated geometric calculations we&#8217;d have to do to figure out the ratio exactly. Since we have to make these calculations for every pixel up to 60 times per second (for smooth animations), our rendering would be pretty slow if we actually did them! Instead, it&#8217;d be nice if we could somehow<br />estimate how much of the pixel is covered and do less work. One approach is to calculate the distance from the pixel to the edge of the shape. If the pixel is more than one pixel&#8217;s distance away from the edge, we know that we should not paint the triangle color at all. If the pixel is closer than one one pixel&#8217;s distance from the edge, we should paint the triangle color, but reduced by some transparency factor.<br /><br />Luckily, OpenGL can run a little program for every pixel <a href='#fn1'>1</a> it paints. This program is called a fragment shader. We can write up this logic in the fragment shader and change the triangle color for every pixel.<br /><br />Perhaps some of those reading who have had experience with OpenGL may notice here that this isn&#8217;t going to work as I&#8217;ve described it. OpenGL already does something like the naive approach I talked about first. Some pixels (the ones OpenGL decided should be painted with the triangle color), will be properly anti-aliased, but many pixels will not be painted at all. For instance, if the coverage of the pixel is only 20% and OpenGL decided not to paint it, we wouldn&#8217;t even have a chance to determine how far it was from the triangle edge, because the fragment shader wouldn&#8217;t run for those missing pixels.</p>

<p>Let&#8217;s &#8220;trick&#8221; OpenGL into painting more pixels than it would otherwise. A simple way to do this is to just make the triangle a little bit bigger. In fact, we can expand all the edges by less than pixel&#8217;s distance and OpenGL will paint all those missing pixels. Now we have smooth edges!</p>

<p><img alt='Expanding the drawing area' src='/edge-distance-anti-aliasing/antialiasing-final-expanded.png' /></p>

<p>I spent some time implementing this for the TextureMapper accelerated compositor (and thus WebKitGTK+), so it&#8217;s not just the Chromium compositor that has this feature any longer. For me it makes a huge difference in the quality of 3D CSS content. For the purposes of demonstration, I&#8217;ve also reimplemented it in WebGL&lt;/a&gt;, so if you have a modern browser you can <a href='/edge-distance-antialiasing'>see it in action</a>.</p>

<p><img alt='A screenshot of the edge-distance anti-aliasing demo' src='/edge-distance-anti-aliasing/antialiasing-final.png' /></p>
<div class='footnotes'>
    <a name='fn1' /><p>1. Fragments and pixels are actually different things, but I'm glossing over this difference for the sake of simplicity.</p>
</div>