---
layout: post
title: "Avoiding the Logging Performance Hit"
date: 2009-04-04
comments: false
---

<div class='post'>
Sometimes you have a function or a method which more often throws away its arguments than actually uses them. Quite possibly the most common example of this situation is logging. Often you'll see a snippet like this:<pre><code><br />log.Debug("Processing " + index + " of " + count);<br /></code></pre><br />It's just the way things are that debug log statements are used more liberally than error statements. Even if log.debug(...) doesn't actually log it's argument, your program will still pay the penalty of doing the string concatenation continuously. As a result many programmers are forced to write code that looks like this:<pre><code><br />if (log.IsDebug()<br />{<br />    log.Debug("Processing " + index + " of " + count);<br />}<br /></code></pre><br />Now the internal state of the logger must be examined externally for every debug statement. D solves this issue through <a href="http://www.digitalmars.com/d/2.0/lazy-evaluation.html">lazily evaluated functional arguments</a>. In D you can change the signature of your function to look like this:<pre><code><br />void Debug(lazy char[] entry)<br />{<br />   if (debug)<br />     fwritefln(logfile, entry());<br />}<br /></code></pre><br />This is really just syntactic sugar around D's delegate parameters in which you can pass a function as an argument. The end result, though, is that the statement that composed the argument won't be evaluated until it is actually used.<br /><br />Titanium and Kroll are written in C++ though, which doesn't have the same kind of syntactic niceties that D does. Recently, when putting the first bits of the logging system into Kroll, I decided that I wasn't satisfied with the Java-style debugging which I wrote above. I wanted to fully encapsulate the behavior of the logger <span style="font-style:italic;">and</span> avoid paying the penalty of uneeded string processing. One common approach for C/C++ is to use macros, but as Walter Bright explains in his essay on lazy argument evaluation, this isn't the best solution.<br /><br />Luckily, C and C++ have variadic arguments which allow us to create both easy-to-read logging code and to avoid paying a penalty for those statements which should essentially be no-ops. I  harnessed the power of a seldom-used friend from the C library for this task: <a href="http://www.opengroup.org/onlinepubs/9699919799/functions/vprintf.html">vsnprintf</a>. vsnprintf operates much like snprintf, except that instead of taking a variable list of arguments it takes a va_list (basically a variadic list of arguments that can be passed forward to other functions). Here is the resulting code from Kroll:<pre><code><br />  std::string Logger::Format(const char* format, va_list args)<br />  {<br />    // Protect the buffer<br />    Poco::Mutex::ScopedLock lock(this->mutex);<br /> <br />    vsnprintf(Logger::buffer, LOGGER_MAX_ENTRY_SIZE - 1, format, args);<br />    Logger::buffer[LOGGER_MAX_ENTRY_SIZE - 1] = '\0';<br />    std::string text = buffer;<br />    return text;<br />  }<br /><br />  void Logger::Log(Level level, const char* format, va_list args)<br />  {<br />    Poco::Logger& loggerImpl = Poco::Logger::get(name);<br /> <br />    // Don't do formatting when this logger filters the message.<br />    // This prevents unecessary string manipulation.<br />    if (level >= (Level) loggerImpl.getLevel())<br />    {<br />      std::string messageText = Logger::Format(format, args);<br />      this->Log(level, messageText);<br />    }<br />  }<br /><br />  void Logger::Debug(const char* format, ...)<br />  {<br />    va_list args;<br />    va_start(args, format);<br />    this->Log(LDEBUG, format, args);<br />  }<br /></code></pre><br />A typical logging statement looks like this:<pre><code><br />log.Debug("Processing %i of %i", index, count);<br /></code></pre></div>
</div>
